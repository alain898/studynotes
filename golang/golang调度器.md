# golang调度器

参考：
* golang实现epoll代码解析[https://zhuanlan.zhihu.com/p/27072761]
* 《Go语言学习笔记》第18章

golang调度器模型中，P对应为物理的CPU核数，M对应为线程，G则对应为协程任务goroutine。
它们之间的关系是这样的，我们可以将P视为令牌，M只有拿到一个令牌P之后，才能够去执行任务G。
P代表了计算的并行度，G代表了计算的并发度。
M的引入有两方面的作用，
一方面"代理"了P作为表征计算并行度的能力，
另一方面用于在M阻塞在执行某个G耗时太多（可能是代码逻辑太复杂，也可能是陷入系统调用太久）时，放弃其持有的P，
让该M暂时专门处理该G，而创建或分配另一个新的M并让其拿着P去执行其它的G，从而不让系统中的所有M都阻塞掉。

以上是golang让异步执行变同步API的方式之一，这种方式是针对"阻塞"式的"系统调用"或cgo这样脱离了golang运行时的执行情况。
下面是异步执行变同步API的方式之二，是针对能够支持"非阻塞"操作的"系统调用"的执行情况。

go程序启动的时候会创建一个M去跑我们的系统监测任务代码

```
systemstack(func() {
     newm(sysmon, nil)
})
```

sysmon方法就是我们说的监控任务，它没有和任何的P(逻辑处理器)进行绑定，
而是通过自身改变睡眠时间和时间间隔来一直循环下去(代码位于runtime/proc.go)。 
golang中***所有文件描述符***都被设置成***非阻塞***的，某个goroutine进行网络io操作，读或者写文件描述符，
如果此刻网络io还没准备好，则这个goroutine会被放到系统的等待队列中，这个goroutine失去了运行权，
但并不是真正的整个系统“阻塞”于系统调用，后台还有一个poller会不停地进行poll，
***所有的文件描述符***都被添加到了这个poller中的，当某个时刻一个文件描述符准备好了，
poller就会唤醒之前因它而阻塞的goroutine，于是goroutine重新运行起来。
换言之，对于能够支持"非阻塞"操作的"系统调用"而言，这种行为更像是内核调度器。


